---
  title: API Promise setTimeout time date 参数化验证
  display: 针对不同情况测试常用API
  image: /image/banner1.jpg
  description: 
  subtitle: 
  date: 2023-08-07
  type: vitest
  author: lrsoy
  toc: true
  duration: ""
---

<DelayTeleport>

[[toc]]
</DelayTeleport>


## 测试的可预测性

保证给予特定输入时所产生的可预测的输出：`也就是说我给什么值，最终会得到什么值，这个最终值是我预期要得到的值` 

### 1.1 随机数

通过使用`vi.spyOn` 在对象的方法或 getter/setter 上创建一个模拟。

<CodeGroup>

  <CodeGroupItem title="mathRandom.spec.js" active>

```ts {7,8,9}
import { vi, it, expect } from 'vitest'
import { matchRandomCreateStr } from './mathRandom'

it('如何测试随机数', () => {

  // 准备数据
  vi.spyOn(Math, 'random').mockImplementation(() => {
    return 0.2
  })
  // 调用
  const n = matchRandomCreateStr(2)
  // 验证
  expect(n).toBe('kk')

})
```

 </CodeGroupItem>

<CodeGroupItem title="mathRandom.js">

```ts
// 随机数的测试: 函数接收一个 长度值 感觉长度值循环随机从字符串中获取一个字符然后赋值给str

export function matchRandomCreateStr(lang: number): string {
  let str = ""
  const character = 'jdlkajlkcxznmfhkjshdfjkaduiasuirejkl'
  for (let index = 0; index < lang; index++) {
    const idx = Math.floor(Math.random() * character.length)
    str += character.charAt(idx)
  }
  return str
}
```

</CodeGroupItem>

</CodeGroup>

### 1.2 日期Date

通过使用`vi.setSystemTime`设置固定日期(过去的)，测试任何依赖于当前日期的内容

<CodeGroup>

  <CodeGroupItem title="dateRan.spec.js" active>

```ts {5,10,18}
import { vi, it, expect, afterEach, beforeEach } from 'vitest'
import { currentDate } from './dateRan'

beforeEach(() => {
  vi.useFakeTimers()
})
it('如何测试日期 固定值今天周五', () => {

  // 准备数据
  vi.setSystemTime(new Date(2023, 7, 4))
  // 调用
  const n = currentDate()
  // 验证
  expect(n).toBe('今天是星期5')

})
afterEach(() => {
  vi.useRealTimers()
})
```

</CodeGroupItem>

  <CodeGroupItem title="dateRan.spec.js" >

```ts
// 测试当前时间是什么

export function currentDate(): string {
  const date = new Date().getDay()
  if (date === 5) {
    return `今天是星期${date}`
  }
  return `今天是星期${date}`
}
```

</CodeGroupItem>

</CodeGroup>



需要注意的是，如果不想因为使用vi.setSystemTime设置固定的过去时间，而影响其他的测试结果，就需要将这个时间恢复，使用`vi.useFakeTimers()`与`vi.useRealTimers()`一起使用将时间恢复，他们不仅仅可以恢复`date`，具体细节参考文档。



## 快速反馈—处理异步代码Promise

在去写测试的时候，要观察被测代码有没有改变任何变量值或者有没有改变系统变量值，找到他的输入与输出，弄清楚后选择合适的方式写测试，没改变任何值只发生了调用就可以使用`行为验证`即可。

### 2.2 延时器与定时器

替换真实的定时器`vi.useFakeTimers`，setTimeout与setInterval都需要使用此方法

#### 2.2.1 延时器 setTimeOut

例：下面例子中要测试`getSetTimeOut`找到他的输入与输出，并没有输出只有调用，在编写测试时，采用行为验证

```ts
export class SetTimeOut {
  id: string;
  constructor(id: string) {
    this.id = id;
  }
  getSetTimeOut(callback: (data: any) => void, delay: number) {
    setTimeout(() => {
      callback(this.id)
    }, delay);
  }
}
```

测：

```ts {4,11,13}
import { vi, it, expect } from 'vitest'
import { SetTimeOut } from './timer'
it('如何测试 setTimeOut', () => {
  vi.useFakeTimers()
  // 准备数据
  const cb = vi.fn()
  // 调用
  const n = new SetTimeOut('1')
  n.getSetTimeOut(cb, 1000)
  1. 方式一
  vi.advanceTimersByTime(1000)
  2. 方式二
  vi.advanceTimersToNextTimer()
  // 验证
  expect(cb).toBeCalledWith('1')
})
```

正常情况下如果不使用`advanceTimersByTime`或者`advanceTimersToNextTimer`是失败的

原因是测试代码是同步的，执行了**调用**的测试就要立刻的去执行**验证**，由于被测代码是异步的延时器，就要等待延时器执行完才去执行内部的回调函数

1. 方式一、采用`advanceTimersByTime`快进时间，他接受一个参数，你需要快进多少秒传入即可
2. 方式二、采用`advanceTimersToNextTimer`快进时间，但不需要接收参数，延时器多少秒就自己就给处理掉了

在处理延时器时，选用方式二是比较好的，好在它不需要传递时间，当源代码时间发生变化，也不需要回头修改测试代码

如果是多个定时器可以直接采用`runAllTimers`一起处理掉

#### 2.2.2 定时器 setInterval

定时器处理与延时器处理有一定的差距，差距在于定时器会每隔一段时间就会执行一次，`就不能采用runAllTimers定时器` ，只能选择上面两种方式

<CodeGroup>

  <CodeGroupItem title="timer.spec.js" active>

```ts {6,13,15}
import { vi, it, expect } from 'vitest'
import { timer } from './timer'

it('如何测试 setInterval', () => {

  vi.useFakeTimers()
  // 准备数据
  vi.spyOn(console, 'log')

  // 调用 
  timer()
  1. 方式一
  vi.advanceTimersByTime(100)
  2. 方式二
  vi.advanceTimersToNextTimer()
  
  // 验证
  expect(console.log).toBeCalledWith('aaa')

})
```

</CodeGroupItem>

 <CodeGroupItem title="timer.js" active>

```ts
export function timer() {
  setInterval(() => {
    console.log('aaa');
  }, 100)
}
```

</CodeGroupItem>

</CodeGroup>



如果出现嵌套使用定时器的情况，直接采用方式一`advanceTimersByTime`将多个定时器时间加起来传递给这个方法，然后让它处理，如果使用方式二，就会有多少个定时器就要调用多少次，来处理每一个定时器

### 2.3 Promise

#### 2.3.1 直接返回Promise

对于直接返回Promise的情况，可以直接使用`async/await`，等待完成之后在执行`验证`

<CodeGroup>

  <CodeGroupItem title="promise.spec.ts" active>

```ts
import { vi, it, expect } from 'vitest'
import { directRtPromise } from './promise'

it('如何测试Promise  直接返回Promise', async () => {

  const n = await directRtPromise()

  expect(n).toBe('ok')

})
```

</CodeGroupItem>

  <CodeGroupItem title="promise.ts" >

```ts
export function directRtPromise() {
  return new Promise((resolve, reject) => {
    resolve('ok')
  })
}
```

</CodeGroupItem>

</CodeGroup>

#### 2.3.2 Promise内嵌setTimeout

```ts
export function promiseNestSetTimeout() {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve('ok'), 1000)
  })
}
```

按照处理直接返回Promise的方式去处理这个，最终的结果虽然是通过的，但是测试执行了很长时间，按照单侧的原则来说，单侧一定执行的块，这种方式就不可取了

![](/vitest/26-29-promis-nest-setTimeout.png)



当里面涉及到setTimeout时，可能一开始想到的就是使用`vi.useFakeTimers()`与`vi.advanceTimersToNextTimer()`去解决定时器问题，而Promise使用`async/await`去解决，但是这种方法并不会成功，控制台输出结果

```ts
it('如何测试Promise  Promise嵌套setTimeout', async () => {

  vi.useFakeTimers()
  const n = await promiseNestSetTimeout()
  vi.advanceTimersToNextTimer()

  expect(n).toBe('ok')

})
```



![](/vitest/26-29-promise-nest-setTimeout-02.png)



导致这种原因是，useFakeTimersu与advanceTimersToNextTimer是配对使用的，useFakeTimersu替换真实的定时器/延时器，而只有调用到advanceTimersToNextTimer才能让promise里面的setTimeout执行，而上面一直在等待，不会执行到advanceTimersToNextTimer

解决：

```ts {5,6,7,12}
import { vi, it, expect } from 'vitest'
import { promiseNestSetTimeout } from './promise'
it('如何测试Promise  Promise嵌套setTimeout', async () => {

  vi.useFakeTimers()
  const n = promiseNestSetTimeout()
  vi.advanceTimersToNextTimer()
  /**
   * 先调用promiseNestSetTimeout执行到定时器在清除掉，验证时因为n返回的是promise
   *   在验证时调用resolves拿到结果去验证
   */	
  expect(n).resolves.toBe('ok')

})
```



#### 2.3.3 链式调用

```ts
export class View {
  count: number = 1;
  render() {
    Promise.resolve().then(() => {
      this.count = 2
    }).then(() => {
      this.count = 3
    })
  }
}
```

使用常规的方法`async/await`针对链式调用的情况，他只能处理一层，后面并没有处理，最终测试count是2而不是3

```ts
it('如何测试Promise  链式调用', async () => {

  const n = new View()

  await n.render()

  expect(n.count).toBe(3)

})
```

![](/vitest/26-29-promise-view.png)

解决：通过使用`flush-promises`库解决链式调用的问题，等待所有的异步完成后在向下执行

```ts
// flush-promises 库源码，直接复制到项目里面，作为工具类引入
var scheduler = typeof setImmediate === 'function' ? setImmediate : setTimeout;

function flushPromises() {
  return new Promise(function (resolve) {
    scheduler(resolve);
  });
}

export default flushPromises
```

```ts {4}
it('如何测试Promise  链式调用', async () => {
  const n = new View()
  n.render()
  await flushPromises()
  expect(n.count).toBe(3)
})
```

